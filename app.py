# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'AlgebraProgram.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from Interface import Ui_MainPage
from someWidget import Ui_Solution
from PyQt5 import QtCore, QtWidgets
from PyQt5.Qt import Qt
import re
from requests import get
from googletrans import Translator
import random
import datetime
import sqlite3 as sq
import time
from threading import Thread
from math import *

translator = Translator()


class MainWindow(QtWidgets.QMainWindow, Ui_MainPage):
    def __init__(self, parent=None):
        QtWidgets.QMainWindow.__init__(self, parent)
        self.setFocusPolicy(Qt.StrongFocus)
        self.setupUi(self)
        self.currentPage = self.MainPageContent
        self.timer = None
        self.QuickColorTimer = None
        self.ForbidInput = False
        self.ms = 3000
        self.index_page = 0
        self.from_exercises = False
        self.tasks = []
        self.curTask = []

        self.actions = {Qt.Key_0: "0", Qt.Key_1: "1", Qt.Key_2: "2", Qt.Key_3: "3", Qt.Key_4: "4", Qt.Key_5: "5",
                   Qt.Key_6: "6", Qt.Key_7: "7",Qt.Key_8: "8", Qt.Key_9: "9"}

        self.tb_texts = {self.btn_sin: "sin(radians(", self.btn_cos: "cos(radians(", self.btn_tan: "tan(radians(", self.btn_pi: "pi",
                         self.btn_fact: "factorial(", self.btn_ln: "log(", self.btn_lg: "log10(", self.btn_log: "log(",
                         self.btn_ex: "exp(", self.btn_sqrt: "sqrt(", self.btn_root: "pow(", self.btn_des: "10**",
                         self.btn_dwa: "**2", self.btn_trzy: "**3", self.btn_degree: "**", self.btn_skob_left: "(",
                         self.btn_skob_right: ")", self.btn_0: "0", self.btn_1: "1", self.btn_2: "2", self.btn_3: "3",
                         self.btn_4: "4", self.btn_5: "5", self.btn_6: "6", self.btn_7: "7", self.btn_8: "8",
                         self.btn_9: "9", self.btn_float: ".", self.btn_del: "/", self.btn_mul: "*",
                         self.btn_plus: "+", self.btn_min: "-", self.btn_abs: "fabs(", self.btn_mod: "fmod(",
                         self.btn_asin: "degrees(asin(", self.btn_acos: "degrees(acos(", self.btn_atan: "degrees(atan("}

        self.typical_buttons = [self.btn_sin, self.btn_cos, self.btn_tan, self.btn_asin, self.btn_pi, self.btn_fact,
                           self.btn_ln, self.btn_lg, self.btn_log, self.btn_ex,
                           self.btn_sqrt, self.btn_root, self.btn_des, self.btn_dwa, self.btn_trzy,
                           self.btn_degree, self.btn_skob_left, self.btn_skob_right, self.btn_0,
                           self.btn_1, self.btn_2, self.btn_3, self.btn_4, self.btn_5, self.btn_6,
                           self.btn_7, self.btn_8, self.btn_9, self.btn_float, self.btn_del, self.btn_mul,
                           self.btn_plus, self.btn_min, self.btn_abs, self.btn_mod, self.btn_atan, self.btn_acos]

        self.cons_pages = {self.action7: self.grade7_theory, self.action8: self.grade8_theory, self.action9: self.grade9_theory,
                           self.action10: self.grade10_theory, self.action11: self.grade11_theory}

        self.cons_buttons = [self.action7, self.action8, self.action9, self.action10, self.action11]

        self.theory_links = {self.turn_to_page_17: [self.PagePrototype_theory_4],
                             self.turn_to_page_18: [self.PagePrototype_theory_2],
                             self.turn_to_page_19: [self.PagePrototype_theory],
                             self.turn_to_page_20: [self.PagePrototype_theory_3],
                             self.turn_to_page_28: [self.PagePrototype_theory_5],
                             self.quitBtn: [self.grade7_theory], self.quitBtn_2: [self.grade7_theory],
                             self.quitBtn_3: [self.grade7_theory], self.quitBtn_4: [self.grade7_theory],
                             self.quitBtn_5: [self.grade8_theory]}

        self.theory_buttons = [self.turn_to_page_17, self.turn_to_page_18, self.turn_to_page_19,
                               self.turn_to_page_20, self.turn_to_page_28,
                               self.quitBtn, self.quitBtn_2, self.quitBtn_3, self.quitBtn_4,
                               self.quitBtn_5]

        self.exercise_blocks = [self.exercises, self.exercises_2, self.exercises_3, self.exercises_4]

        self.exercise_buttons = [[self.exercise_btn, 1], [self.exercise_btn_2, 2], [self.exercise_btn_3, 3],
                                 [self.exercise_btn_4, 4]]

        self.connected_objects = {self.PagePrototype_theory: [self.task, self.variants, self.seeSolution,
                                                              self.getTasksAgain, self.ContinueSolving,self.Check],
                                  self.PagePrototype_theory_2: [self.task_2, self.variants_2, self.seeSolution_2,
                                                              self.getTasksAgain_2, self.ContinueSolving_2, self.Check_2],
                                  self.PagePrototype_theory_3: [self.task_3, self.variants_3, self.seeSolution_3,
                                                              self.getTasksAgain_3, self.ContinueSolving_3, self.Check_3],
                                  self.PagePrototype_theory_4: [self.task_4, self.variants_4, self.seeSolution_4,
                                                              self.getTasksAgain_4, self.ContinueSolving_4, self.Check_4],
                                  }

        self.get_tasks = [self.getTasksAgain, self.getTasksAgain_2, self.getTasksAgain_3, self.getTasksAgain_4]
        self.variativity = [self.variants, self.variants_2, self.variants_3, self.variants_4]
        self.continue_solvings = [self.ContinueSolving, self.ContinueSolving_2, self.ContinueSolving_3, self.ContinueSolving_4]
        self.checks = [self.Check, self.Check_2, self.Check_3, self.Check_4]
        self.solutions = [self.seeSolution, self.seeSolution_2, self.seeSolution_3, self.seeSolution_4]

        self.taskResult = None
        self.answer = ""
        self.right = 0
        self.wrong = 0
        self.solved = 0
        self.exerciseMath = False
        self.times_spent = []
        self.last_time_solved = 0
        self.remembered_number = "0"
        self.group_exercise = [self.RemainedTime, self.SolvedTasks]
        self.group_practice = [self.Finish, self.PercentRight, self.RightAnswers, self.WrongAnswers]
        self.connectButtons()


    def closeEvent(self, event):
        answerWidget.close()
        event.accept()


    def keyPressEvent(self, e):
        super().keyPressEvent(e)
        if self.currentPage == self.EndlessField and not self.ForbidInput:
            if e.key() == Qt.Key_Backspace and not self.Task.text()[-1] == " ":
                    self.Task.setText(self.Task.text()[:-1])
                    self.answer = self.answer[:-1]
            if e.key() == Qt.Key_Minus and self.Task.text()[-1] == " " and int(self.taskResult) < 0:
                    self.Task.setText(self.Task.text() + "-")
                    self.answer += "-"
            for key in self.actions.keys():
                    if key == e.key():
                        self.answer += self.actions[key]
                        self.Task.setText(self.Task.text() + self.actions[key])
                        if len(self.answer) == len(self.taskResult):
                            if self.answer == self.taskResult:
                                    if not self.exerciseMath:
                                        self.right += 1
                                    else:
                                        self.solved += 1
                                        self.SolvedTasks.setText(f"Решено примеров: {self.solved}")
                                        self.times_spent.append((datetime.datetime.now() - self.last_time_solved).total_seconds())
                                        self.last_time_solved = datetime.datetime.now()
                                    self.Task.setStyleSheet("color: #00ff00")
                            else:
                                    if not self.exerciseMath:
                                        self.wrong += 1
                                    else:
                                        self.times_spent.append((datetime.datetime.now() - self.last_time_solved).total_seconds())
                                        self.getToResult()
                                    self.Task.setStyleSheet("color: #ff0000")
                            if not self.exerciseMath:
                                    self.QuickColorTimer = QtCore.QTimer()
                                    self.QuickColorTimer.timeout.connect(self.generateTask)
                                    self.QuickColorTimer.start(300)
                                    self.ForbidInput = True
                                    self.RightAnswers.setText(f"Правильных ответов: {self.right}")
                                    self.WrongAnswers.setText(f"Неправильных ответов: {self.wrong}")
                                    self.PercentRight.setText(f"Правильность ответов: {round((self.right / (self.right+self.wrong))*100, 2)}%")
                            else:
                                    self.generateTask()




    def changePages(self, obj1, obj2, x1, y1, x2, y2):
            self.currentPage = obj2
            obj1.setGeometry(x1, y1, obj1.width(), obj1.height())
            obj2.setGeometry(x2, y2, obj2.width(), obj2.height())

    def setTimerTime(self):
            minutes = str(self.ms // 60000)
            seconds = str((self.ms - int(minutes)*60000) // 1000)
            if len(minutes) == 1:
                    minutes = "0" + minutes
            if len(seconds) == 1:
                    seconds = "0" + seconds
            return f"{minutes}:{seconds}"

    def generateTask(self):
            if self.QuickColorTimer != None and self.ForbidInput:
                    self.ForbidInput = False
                    self.QuickColorTimer.stop()
            operations = ["+", "-", "*", "//"]
            operation = random.choice(operations)
            if operation in ["+", "-"]:
                    first_number = random.randint(1, 999)
                    second_number = random.randint(1, 999)
            else:
                    if operation == operations[2]:
                            variant = [1, 2]
                            if random.choice(variant) == 1:
                                    mnozh = random.randint(2, 10)
                                    first_number = random.randint(1, 10 * mnozh)
                                    second_number = random.randint(1, 10 * mnozh)
                            else:
                                    first_number = random.randint(1, 999)
                                    second_number = random.randint(1, 9)
                    else:
                            variant = [1, 2]
                            if random.choice(variant) == 2:
                                    while 1:
                                            first_number = random.randint(1, 99)
                                            second_number = random.randint(2, 99)
                                            if first_number % second_number != 0:
                                                    continue
                                            break
                            else:
                                    while 1:
                                            first_number = random.randint(1, 999)
                                            second_number = random.randint(2, 9)
                                            if first_number % second_number != 0:
                                                    continue
                                            break
            self.Task.setText(f"{first_number} {operation} {second_number} = ")
            self.taskResult = str(eval(f"{first_number}{operation}{second_number}"))
            self.answer = ""
            self.Task.setStyleSheet("color: #ffffff")


    def mathTestResults(self, remained, solved, middle, date):
        with sq.connect("resultDatabase.db") as db:
            cursor = db.cursor()
            requestGet = "SELECT remained_time, solved_tasks, middle_time, date FROM results ORDER BY solved_tasks DESC, remained_time DESC, middle_time ASC LIMIT 5"
            cursor.execute("CREATE TABLE IF NOT EXISTS results ("
                           "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                           "remained_time INTEGER NOT NULL,"
                           "solved_tasks INTEGER NOT NULL,"
                           "middle_time REAL NOT NULL,"
                           "date TEXT NOT NULL"
                           ")")
            cursor.execute(
                "INSERT INTO results (remained_time, solved_tasks, middle_time, date) VALUES (?, ?, ?, ?)",
                (remained, solved, middle, date))
            db.commit()
            cursor.execute("SELECT * FROM results")
            all_results = cursor.fetchall()
            if len(all_results) > 10:
                cursor.execute(f"DELETE FROM results WHERE (remained_time, solved_tasks, middle_time, date) NOT IN ({requestGet})")
                db.commit()
            cursor.execute(requestGet)
            top_results = cursor.fetchall()
            row = 0
            for result in top_results:
                col = 0
                for item in result:
                    cell = QtWidgets.QTableWidgetItem(str(item))
                    self.DataBaseTries.setItem(row, col, cell)
                    col += 1
                row += 1
        return


    def getToResult(self):
            solved = self.solved
            remained = self.setTimerTime()
            middle = round(sum(self.times_spent) / len(self.times_spent), 2)
            date = time.strftime("%d.%m.%Y г. %H:%M", time.localtime())
            self.changePages(self.currentPage, self.ResultField, 1000, 0, 0, 0)
            self.Solved.setText(f"Решено примеров всего: {solved}")
            self.UnusedTime.setText(f"Оставшееся время: {remained}")
            self.Fluency.setText(f"Среднее время решения: {middle} сек.")
            threadResults = Thread(target=lambda: self.mathTestResults(remained, solved, middle, date))
            threadResults.start()


    def updateRemainedTime(self):
            self.ms -= 1000
            if self.ms < 0:
                self.ms = 0
                self.times_spent.append((datetime.datetime.now() - self.last_time_solved).total_seconds())
                self.timer.stop()
                self.getToResult()
                return
            self.RemainedTime.setText(self.setTimerTime())


    def updateReady(self, isTraining):
            self.ms -= 1000
            if self.ms < 0:
                    self.ms = 0
                    self.timer.stop()
                    self.generateTask()
                    if not isTraining:
                        self.ms = 120000
                        self.last_time_solved = datetime.datetime.now()
                        self.timer = QtCore.QTimer()
                        self.timer.timeout.connect(self.updateRemainedTime)
                        self.timer.start(1000)
                    self.ForbidInput = False
                    self.setFocusPolicy(Qt.StrongFocus)
                    self.changePages(self.currentPage, self.EndlessField, 1000, 0, 0, 0)
            else:
                    self.TimerBack.setText(self.setTimerTime())


    def setStyleMenu(self, isAvail, style):
        self.Menu.setEnabled(isAvail)
        self.Menu.setStyleSheet(style)


    def startTimer(self, obj1, obj2, x1, y1, x2, y2, isTraining):
            self.setStyleMenu(False, """font: italic 14pt "Times New Roman";
    color: rgb(85, 0, 0);
    background-color: #afafaf""")
            self.changePages(obj1, obj2, x1, y1, x2, y2)
            self.timer = QtCore.QTimer()
            self.ms = 5000
            self.TimerBack.setText(self.setTimerTime())
            if isTraining:
                    self.right = 0
                    self.wrong = 0
                    self.exerciseMath = False
                    self.RightAnswers.setText("Правильных ответов: 0")
                    self.WrongAnswers.setText("Неправильных ответов: 0")
                    self.PercentRight.setText("Правильность ответов: 0%")
                    for obj in self.group_exercise:
                        obj.hide()
                    for obj in self.group_practice:
                        obj.show()

            else:
                self.solved = 0
                self.times_spent = []
                self.SolvedTasks.setText("Решено примеров: 0")
                self.RemainedTime.setText("02:00")
                self.exerciseMath = True
                for obj in self.group_exercise:
                        obj.show()
                for obj in self.group_practice:
                        obj.hide()

            self.timer.timeout.connect(lambda: self.updateReady(isTraining))
            self.timer.start(1000)

    def getBackToMain(self):
            self.changePages(self.currentPage, self.StartPage, 1000, 0, 0, 0)
            self.setStyleMenu(True, """font: italic 14pt "Times New Roman";
    color: rgb(85, 0, 0);
    background-color: rgb(170, 255, 127);""")
            self.QuickColorTimer = None
            self.currentPage = self.MathSolving

    def getDateEdit(self):
            self.DateEdit.setGeometry(220, 350, self.DateEdit.width(), self.DateEdit.height())
            self.mathYearTriviaEdit.hide()
            self.DateEdit.show()

    def getMathEdit(self):
            self.DateEdit.hide()
            self.mathYearTriviaEdit.show()

    def validation(self):
            if (self.DateFact.isChecked() and re.findall(r"^[0-9]{1,2}/[0-9]{1,2}$", self.DateEdit.text()) != []) or (
                    not self.DateFact.isChecked() and re.findall(r"^[0-9]{1,8}$", self.mathYearTriviaEdit.text())):
                    return True


    def getNumberFact(self, number, type):
         try:
             originalText = get(f"http://numbersapi.com/{number}/{type}").text
             self.ResultLabelFact.setText(
                 originalText + "\n" + translator.translate(originalText, dest='ru').text)
         except:
             self.ResultLabelFact.setText("Не получилось получить факт, проверьте интернет-соединение.")
         finally:
             return


    def getInfo(self):
            if self.validation():
                    if self.DateFact.isChecked():
                            number = self.DateEdit.text()
                            type = "date"
                    else:
                            number = self.mathYearTriviaEdit.text()
                            if self.MathFact.isChecked():
                                    type = "math"
                            elif self.YearFact.isChecked():
                                    type = "year"
                            else:
                                    type = "trivia"
                    threadGet = Thread(target=lambda: self.getNumberFact(number, type))
                    threadGet.start()
                    return
            self.ResultLabelFact.setText("Некорректный ввод данных!\nПопробуйте ещё раз.")

    def clearCalculatorTask(self):
        self.request.setText("")
        self.hint_entered.setText("")

    def clearSymbol(self):
        cursor_pos = self.request.cursorPosition()
        try:
            self.request.setText(self.request.text()[:cursor_pos-1] + self.request.text()[cursor_pos:])
        except:
            pass

    def showResult(self):
        try:
            if self.request.text().startswith("os") or self.request.text().startswith("__"):
                raise ArithmeticError
            if self.radians.isChecked():
                self.request.setText(re.sub(r"degrees", "", self.request.text()))
                self.request.setText(re.sub(r"radians", "", self.request.text()))

            task = self.request.text()
            self.request.setText(str(round(eval(self.request.text()), 4)))
            self.hint_entered.setText(task + f" = {self.request.text()}")
        except:
            self.request.setText("")
            self.hint_entered.setText("Ошибка!")

    def printRemembered(self):
        cursor_pos = self.request.cursorPosition()
        self.request.setText(self.request.text()[:cursor_pos] + self.remembered_number + self.request.text()[cursor_pos:])

    def clearRemembered(self):
        self.remembered_number = "0"
        self.hint_entered.setText(self.remembered_number)

    def saveRemembered(self):
        if re.search(r'^-?[0-9]{1,}\.?[0-9]{0,}$', self.request.text()):
            self.remembered_number = self.request.text()
            self.hint_entered.setText(self.remembered_number)

    def changeRemembered(self, sign):
        if re.search(r'^-?[0-9]{1,}\.?[0-9]{0,}$', self.request.text()):
            self.remembered_number = str(float(self.remembered_number) + sign*float(self.request.text()))
            self.hint_entered.setText(self.remembered_number)


    def buttonSolve(self, button, activeness):
        button.setEnabled(activeness)


    def updateEqParameters(self):
        texts = [self.field_a.text(), self.field_b.text(), self.field_c.text()]
        if any([i == "" for i in texts]) or any([re.search(r"^-?[0-9]+\.?[0-9]*$", i) == None for i in texts]) or texts[0] == "0" or \
                any([len(i) > 1 and i.startswith("0") for i in texts]):
            self.equation.setText("ax² + bx + c = 0")
            self.buttonSolve(self.solve_equation, False)
            return
        arg_b = "+ " + texts[1] if '-' not in texts[1] else "- " + re.findall(r"[0-9]+\.?[0-9]*", texts[1])[0]
        arg_c = "+ " + texts[2] if '-' not in texts[2] else "- " + re.findall(r"[0-9]+\.?[0-9]*", texts[2])[0]
        self.equation.setText(f"{texts[0]}x² {arg_b}x {arg_c} = 0")
        self.equation.setText(re.sub(r"[\+-] 0x?", "", self.equation.text()))
        self.equation.setText(re.sub(r"1x²", "x²", self.equation.text()))
        self.equation.setText(re.sub(r"1x", "x", self.equation.text()))
        self.buttonSolve(self.solve_equation, True)


    def solveEquation(self):
        integers = [float(self.field_b.text()), float(self.field_a.text()), float(self.field_c.text())]
        string_objs = [f"({integers[0]})" if "-" in str(integers[0]) else f"{integers[0]}",
                       f"({integers[1]})" if "-" in str(integers[1]) else f"{integers[1]}",
                       f"({integers[2]})" if "-" in str(integers[2]) else f"{integers[2]}"]
        discr = round(integers[0]**2 - 4*integers[1]*integers[2], 6)
        conclusion = ""
        if discr < 0:
            conclusion = "Поскольку D отрицательный, данное уравнение не имеет действительных решений."
            self.frame_two_Answers.setGeometry(1000,380, self.frame_two_Answers.width(), self.frame_two_Answers.height())
        elif discr == 0:
            conclusion = "Поскольку D = 0, данное уравнение имеет одно действительное решение:"
            self.frame_two_Answers.setGeometry(0,380, self.frame_two_Answers.width(), self.frame_two_Answers.height())
            self.frame_one_answer.setGeometry(0,10, self.frame_one_answer.width(), self.frame_one_answer.height())
            self.real_solution_4.setText(f"<html><head/><body><p><span style='text-decoration: underline;'>-{string_objs[0]}<br/></span>2*{string_objs[1]}</p></body></html>")
            self.answer_first_4.setText(f"{round(((-1)*integers[0])/(2*integers[1]),6)}")
        else:
            self.frame_two_Answers.setGeometry(0, 380, self.frame_two_Answers.width(), self.frame_two_Answers.height())
            self.frame_one_answer.setGeometry(1000, 10, self.frame_one_answer.width(), self.frame_one_answer.height())
            self.real_solution.setText(f"<html><head/><body><p><span style=' text-decoration: underline;'>-{string_objs[0]} - √{discr}<br/></span>2*{string_objs[1]}</p></body></html>")
            self.real_solution_2.setText(f"<html><head/><body><p><span style=' text-decoration: underline;'>-{string_objs[0]} + √{discr}<br/></span>2*{string_objs[1]}</p></body></html>")
            self.answer_first.setText(f"{round(((-1)*integers[0] - sqrt(discr))/(2*integers[1]),6)}")
            self.answer_first_2.setText(f"{round(((-1) * integers[0] + sqrt(discr)) / (2 * integers[1]), 6)}")
            conclusion = "Поскольку D положительный, данное уравнение имеет два действительных решения:"
        self.disc.setText(f"<html><head/><body><p>D = b<span style='vertical-align:super;'>2</span>-4ac = "
                          f"{string_objs[0]}<span style='vertical-align:super;'>2</span>-4*{string_objs[1]}*{string_objs[2]}"
                          f" = {discr}<br/>{conclusion}</p></body></html>")


    def updateNParams(self):
        if len(self.solution.text()) != 0:
            self.solution.setText("")
        if self.nod.isChecked():
            self.find_NOD.setText("Найти НОД!")
        else:
            self.find_NOD.setText("Найти НОК!")
        if re.findall(r"^-?[1-9][0-9]*$", self.num_a.text()) and re.findall(r"^-?[1-9][0-9]*$", self.num_b.text()):
            self.buttonSolve(self.find_NOD, True)
        else:
            self.buttonSolve(self.find_NOD, False)


    def imagineEasy(self, number):
        divisors = [str(1)]
        while number != 1:
            for i in range(2, number+1):
                if number % i == 0:
                    divisors.append(str(i))
                    number //= i
                    break
        if divisors != [str(1)]:
            divisors.remove(str(1))
        return divisors

    def findResult(self):
        a = abs(int(self.num_a.text()))
        b = abs(int(self.num_b.text()))
        c, d = a, b
        self.solution.setText(f"Рассматриваемые числа: {a} и {b}\n")
        if self.nod.isChecked():
            self.solution.setText(self.solution.text() + "Будем из большего числа вычитать меньшее, пока результат не станет равным 0. Если число отрицательное, берём значение его модуля\n")
            while a != 0 and b != 0:
                if a > b:
                    self.solution.setText(self.solution.text() + f"{a} - {b} = {a-b}\n")
                    a -= b
                else:
                    self.solution.setText(self.solution.text() + f"{b} - {a} = {b-a}\n")
                    b -= a
            self.solution.setText(self.solution.text() + f"НОД чисел {c} и {d}: {a or b}")
        else:
            self.solution.setText(self.solution.text() + "Если число отрицательное, берём значение его модуля.\nРазложим оба числа на простые множители. Возьмём группу множителей большего числа и к ней добавим множители из другой группы, которые в данной отсутствуют. Перемножим полученные множители.\n")
            div_a = self.imagineEasy(min(a,b))
            div_b = self.imagineEasy(max(a,b))
            self.solution.setText(self.solution.text() + f"{min(a,b)} = {' * '.join(div_a)}\n")
            self.solution.setText(self.solution.text() + f"{max(a,b)} = {' * '.join(div_b)}\n")
            new_divisors = list(map(str, list(set(div_a) - set(div_b))))
            self.solution.setText(self.solution.text() + f"Из группы множителей числа {min(a,b)} можем добавить в {max(a,b)} множители: {','.join(new_divisors)}\n")
            self.solution.setText(self.solution.text() + f"Тогда остаётся найти произведение: {' * '.join(div_b + new_divisors)}\n")
            mn = 1
            for i in (div_b + new_divisors):
                mn *= int(i)
            self.solution.setText(self.solution.text() + f"НОК чисел {a} и {b}: {mn}")


    def getTasks(self, isStart, isNext):
        with sq.connect("Tasks.db") as con:
            cursor = con.cursor()
            if not isNext:
                self.tasks = cursor.execute(f"""SELECT task, variants, answer, solution FROM Tasks WHERE ind = {self.index_page}""").fetchall()
                self.connected_objects[self.currentPage][3].setEnabled(False)
                if not isStart:
                    self.connected_objects[self.currentPage][4].setEnabled(True)
            if isStart:
                if not answerWidget.isHidden():
                    answerWidget.hide()
                self.task = self.tasks[random.randint(0, len(self.tasks) - 1)]
                self.tasks.remove(self.task)
                self.connected_objects[self.currentPage][0].setText(self.task[0])
                variant = self.connected_objects[self.currentPage][1]
                variant.setStyleSheet("""QComboBox {
border-color: rgb(153, 153, 0);
background-color: rgb(217, 255, 255);
font-size: 22px;
font-family: "Times New Roman";
}""")
                variant.clear()
                chooses = self.task[1].split("\r\n")
                random.shuffle(chooses)
                for var in chooses:
                    variant.addItem(var.strip())
                for obj in self.connected_objects[self.currentPage][2:5]:
                    obj.setEnabled(False)
                self.connected_objects[self.currentPage][5].setEnabled(True)
                self.connected_objects[self.currentPage][1].setEnabled(True)


    def moveblock(self, btn, ind):
        self.index_page = ind
        if self.index_page == ind and self.from_exercises == False:
            self.getTasks(isStart=True, isNext=False)
        for child in btn.parent().parent().children():
            if "content" in child.objectName() and not child.isHidden():
                child.hide()
                self.setStyleMenu(False, """font: italic 14pt "Times New Roman";
                color: rgb(85, 0, 0);
                background-color: #afafaf""")
            elif "content" in child.objectName() and child.isHidden():
                child.show()
                self.setStyleMenu(True, """font: italic 14pt "Times New Roman";
    color: rgb(85, 0, 0);
    background-color: rgb(170, 255, 127);""")
            if "exercises" in child.objectName() and child.isHidden():
                child.show()
                btn.setText("<<< К теории")
                btn.setStatusTip("Вернуться к теории, что приведёт к сбросу прогресса")
                for button in btn.parent().children():
                    if "quit" in button.objectName():
                        button.hide()
                self.from_exercises = True
            elif "exercises" in child.objectName() and not child.isHidden():
                child.hide()
                if not answerWidget.isHidden():
                    answerWidget.hide()
                btn.setText("Упражнения >>>")
                btn.setStatusTip("Перейти к упражнениям")
                for button in btn.parent().children():
                    if "quit" in button.objectName():
                        button.show()
                self.from_exercises = False


    def afterChecking(self, css, checkActivity):
        self.connected_objects[self.currentPage][1].setStyleSheet(css)
        for obj in self.connected_objects[self.currentPage][2:5]:
            obj.setEnabled(True)
        self.connected_objects[self.currentPage][5].setEnabled(checkActivity)


    def checkAnswer(self):
        if self.task[2].strip() == self.connected_objects[self.currentPage][1].currentText().strip():
            self.connected_objects[self.currentPage][1].setEnabled(False)
            self.afterChecking("""QComboBox {
border-color: rgb(153, 153, 0);
	background-color: rgb(0, 214, 0);
font-size: 22px;
font-family: "Times New Roman";
}""", False)
        else:
            self.afterChecking("""QComboBox {
border-color: rgb(153, 153, 0);
	background-color: rgb(255, 85, 0);
font-size: 22px;
font-family: "Times New Roman";
}""", True)
        if self.tasks == []:
            self.connected_objects[self.currentPage][4].setEnabled(False)


    def setOldStyle(self):
        self.connected_objects[self.currentPage][1].setStyleSheet("""QComboBox {
border-color: rgb(153, 153, 0);
background-color: rgb(217, 255, 255);
font-size: 22px;
font-family: "Times New Roman";
}""")


    def viewSolution(self):
        answerWidget.answer.setText(self.task[3].strip())
        answerWidget.show()


    def connectButtons(self):
            self.action.triggered.connect(
                    lambda: self.changePages(self.currentPage, self.MainPageContent, 1000, 10, 0, 10))
            self.action_13.triggered.connect(
                    lambda: self.changePages(self.currentPage, self.FactsPage, 1000, 10, 0, 10))
            self.action_14.triggered.connect(
                    lambda: self.changePages(self.currentPage, self.MathSolving, 1000, 10, 0, 10))
            self.StartPage.setGeometry(0, 0, self.StartPage.width(), self.StartPage.height())
            self.Free.clicked.connect(
                    lambda: self.startTimer(self.StartPage, self.GettingReady, 1000, 0, 0, 0, isTraining=True))
            self.Unmistake.clicked.connect(lambda: self.startTimer(self.StartPage, self.GettingReady, 1000, 0, 0, 0, isTraining=False))
            self.ReturnBack.clicked.connect(self.getBackToMain)
            self.Repeat.clicked.connect(lambda: self.startTimer(self.ResultField, self.GettingReady, 1000, 0, 0, 0, isTraining=False))
            self.SkillsCount.clicked.connect(lambda: self.changePages(self.currentPage, self.SkillCountArticle, 1000, 10, 0, 10))
            self.backMathButton.clicked.connect(lambda: self.changePages(self.currentPage, self.MathSolving, 1000, 10, 0, 10))
            self.action_8.triggered.connect(lambda: self.changePages(self.currentPage, self.Calculator_Big, 1000, 10, 0, 10))
            self.action_9.triggered.connect(lambda: self.changePages(self.currentPage, self.Equation_square, 1000, 10, 0, 10))
            self.action_3.triggered.connect(lambda: self.changePages(self.currentPage, self.NOD, 1000, 10, 0, 10))
            self.buttonSolve(self.solve_equation, False)
            self.buttonSolve(self.find_NOD, False)
            self.find_NOD.setText("Найти НОД!")
            self.solve_equation.clicked.connect(self.solveEquation)
            self.num_a.textChanged.connect(self.updateNParams)
            self.num_b.textChanged.connect(self.updateNParams)
            self.nod.toggled.connect(self.updateNParams)
            self.nok.toggled.connect(self.updateNParams)
            self.find_NOD.clicked.connect(self.findResult)
            self.field_a.textChanged.connect(self.updateEqParameters)
            self.field_b.textChanged.connect(self.updateEqParameters)
            self.field_c.textChanged.connect(self.updateEqParameters)
            self.DeleteAll.clicked.connect(self.clearCalculatorTask)
            self.DeleteLastSymbol.clicked.connect(self.clearSymbol)
            self.request.returnPressed.connect(self.showResult)
            self.btn_result.clicked.connect(self.showResult)
            self.MC_btn.clicked.connect(self.clearRemembered)
            self.MS_btn.clicked.connect(self.saveRemembered)
            self.MR_btn.clicked.connect(self.printRemembered)
            self.M_plus_btn.clicked.connect(lambda: self.changeRemembered(1))
            self.M_minus_btn.clicked.connect(lambda: self.changeRemembered(-1))


            for ex in self.exercise_blocks:
                ex.hide()


            for button in range(len(self.typical_buttons)):
                self.typical_buttons[button].clicked.connect(lambda event, text=self.tb_texts[self.typical_buttons[button]]: \
                    self.request.setText(self.request.text()[:self.request.cursorPosition()] + text + \
                                         self.request.text()[self.request.cursorPosition():]))

            for button in self.cons_buttons:
                button.triggered.connect(lambda event, page=self.cons_pages[button]: \
                                            self.changePages(self.currentPage, page, 1000, 10, 0, 10))


            for button in self.theory_buttons:
                if button in self.theory_links.keys():
                    button.clicked.connect(lambda event, page=self.theory_links[button][0]: \
                                           self.changePages(self.currentPage, page, 1000, 10, 0, 10))


            for button in self.exercise_buttons:
                button[0].clicked.connect(lambda event, btn=button[0], ind=button[1]: self.moveblock(btn, ind))



            for btn in self.get_tasks:
                btn.clicked.connect(lambda: self.getTasks(isStart=False, isNext=False))

            for btn in self.continue_solvings:
                btn.clicked.connect(lambda: self.getTasks(isStart=True, isNext=True))

            for btn in self.checks:
                btn.clicked.connect(self.checkAnswer)

            for box in self.variativity:
                box.currentTextChanged.connect(self.setOldStyle)

            for btn in self.solutions:
                btn.clicked.connect(self.viewSolution)


            self.Finish.clicked.connect(self.getBackToMain)
            self.action_2.triggered.connect(self.exit)
            self.QuitBtn.clicked.connect(self.exit)
            self.DateFact.toggled.connect(self.getDateEdit)
            self.MathFact.toggled.connect(self.getMathEdit)
            self.TriviaFact.toggled.connect(self.getMathEdit)
            self.YearFact.toggled.connect(self.getMathEdit)
            self.getFact.clicked.connect(self.getInfo)



    def exit(self):
        app.quit()


class WidgetAnswer(QtWidgets.QWidget, Ui_Solution):
    def __init__(self, parent=None):
        QtWidgets.QWidget.__init__(self, parent=parent)
        self.setupUi(self)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    mainWindow = MainWindow()
    answerWidget = WidgetAnswer()
    mainWindow.show()
    sys.exit(app.exec_())
